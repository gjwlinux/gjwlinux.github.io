<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go语言if,swith,for]]></title>
    <url>%2F2019%2F10%2F21%2FGo%E8%AF%AD%E8%A8%80if-swith-for%2F</url>
    <content type="text"><![CDATA[if判断 判断变量 1234567891011121314151617181920package mainimport ( &quot;fmt&quot;)func main() &#123; a := 18 if a == 18 &#123; fmt.Println(&quot;=18&quot;) &#125;else if a &lt; 18 &#123; fmt.Println(&quot;&lt;18&quot;) &#125;else &#123; fmt.Println(&quot;&gt;18&quot;) &#125; //=18&#125; 也可以在判断中声明值 12345678910111213141516171819package mainimport ( &quot;fmt&quot;)func main() &#123; if a := 17; a == 18 &#123; fmt.Println(&quot;=18&quot;) &#125;else if a &lt; 18 &#123; fmt.Println(&quot;&lt;18&quot;) &#125;else &#123; fmt.Println(&quot;&gt;18&quot;) &#125; //&lt;18&#125; swith 语句 示例一: 1234567891011121314151617181920212223242526272829303132package mainimport &quot;fmt&quot;//定义函数，参数为int，返回值为strfunc grade(source int)string &#123; s := &quot;&quot; //根据传入值判断，如果匹配到就直接返回 //fallthrough 匹配到也可以继续向下匹配 switch &#123; case source &gt;= 90 &amp;&amp; source &lt; 100: s = &quot;A&quot; // fallthrough case source &lt; 80: s = &quot;B&quot; case source &lt; 60: s = &quot;C&quot; //如果以上都不是返回其他 default: s = &quot;其他&quot; &#125; return s&#125;func main() &#123; fmt.Println(grade(0)) fmt.Println(grade(101)) fmt.Println(grade(99)) /* B 其他 A */&#125; 示例二: 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; s:= &quot;a&quot; //判断字符串s，匹配a，b，c switch s &#123; case &quot;a&quot;,&quot;b&quot;,&quot;c&quot;: fmt.Println(&quot;找到了&quot;) default: fmt.Println(&quot;没找到&quot;) &#125; //找到了&#125; for 循环 语法:初始化语句，条件语句，结束语句123456789101112131415161718192021222324252627282930313233package mainimport &quot;fmt&quot;func main() &#123; //初始化语句，判断语句，结束条件 for i:=0;i&lt;3 ;i++ &#123; fmt.Println(i) &#125; /* 0 1 2 */ //条件放在了外面，初始化语句空着即可 i := 0 for ; i&lt;3; i++ &#123; fmt.Println(i) &#125; /* 0 1 2 */ //多个初始化语句 for i,j:=10,1;i&lt;12&amp;&amp;j&lt;3 ;i,j =i+1,j+1 &#123; fmt.Println(i,&quot; &quot;,j) &#125; /* 10 1 11 2 */&#125; rang]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言命令行交互]]></title>
    <url>%2F2019%2F10%2F21%2FGo%E8%AF%AD%E8%A8%80%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; var a1 int fmt.Println(&quot;请输出一个整数: &quot;) fmt.Scan(&amp;a1) fmt.Printf(&quot;a1=%d&quot;,a1) /* 请输出一个整数: 1 a1=1 */&#125;]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go常用数据类型]]></title>
    <url>%2F2019%2F10%2F21%2FGo%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[整型1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)// 单行注释/*多行注释*/func main() &#123; //int 8占一个字节,16占2个依此类推 // int,uint 根据平台来判断 var v1 int32 v1 = 1 v2 := 2 fmt.Println(v1,v2) //反射方法，得出数据类型fmt.Println(reflect.TypeOf(v1))fmt.Println(reflect.TypeOf(v2)) /* 1 2 int32 int */&#125; 浮点型 go语言中只有float32与float64123456789101112131415161718192021package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)func main() &#123; var v1 float32 v1 = 1 v2 := 1.5 fmt.Println(v1,v2) fmt.Println(reflect.TypeOf(v1)) fmt.Println(reflect.TypeOf(v2)) /* 1 1.5 float32 float64 */ //默认推导与平台相关&#125; 布尔值 go 中布尔值只有true，false，没有0/1123456789package mainimport &quot;fmt&quot;func main() &#123; var v1 bool v1 = true fmt.Println(v1)&#125; 字符串 以双引号定义，单引号为字符123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123; var s string s = &quot;abc&quot; fmt.Println(s) st := &quot;abc&quot; fmt.Println(st) //原样输出 s1 := ` hello world \n\r xxx` fmt.Println(s1) /* abc abc hello world \n\r xxx */&#125; ###自定义类型 type 关键字定义123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)func main() &#123; type myint int var a1 myint a1 = 100 fmt.Println(a1) fmt.Println(reflect.TypeOf(a1)) /* 100 main.myint */&#125;]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go语言变量与常量]]></title>
    <url>%2F2019%2F10%2F21%2FGo%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[命名规范 go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则 必须以一个字母或下划线_开头，后面可以跟任意数量的字母、数字或下划线 go语言中大小写字母认为是不同的 go语言中有25个关键字，不能用于自定义名字 定义变量 go语言中变量以var关键字命名 1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() &#123; //单个，多个定义方式 var v1 int var v2,v3 int var( v4 int v5 int ) //赋值 v1 = 1 v2 = 2 v3 = 3 //多重赋值 v4,v5 = 4,5 fmt.Println(v1,v2,v3,v4,v5)&#125; 变量自动推倒 123456789101112package mainimport &quot;fmt&quot;func main() &#123; //不声明类型，直接赋值 //变量推倒，只适用于函数内部 var v1 = 2 v2 := 2 fmt.Println(v1,v2) fmt.Printf(&quot;%T,%T&quot;,v1,v2)&#125; 匿名变量 123456789101112package mainimport &quot;fmt&quot;//定义一个函数，返回值为两个intfunc test()(int,int)&#123; return 1,2&#125;func main()&#123; //下划线_接收，在函数返回多个值又不需要的时候使用 v1, _ := test() fmt.Println(v1)&#125; 常量 const 关键字定义，常量不可变，const也可以定义枚举1234567891011121314package mainimport &quot;fmt&quot;//单个常量定义const file = &quot;test.txt&quot;//多个常量定义const ( file1 = &quot;a.txt&quot; file2 = &quot;b.txt&quot;) func main() &#123; fmt.Println(file,file1,file2)&#125; 枚举与iota12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;fmt&quot;)//在const中省略的值，和前面的值相同func enums1()&#123; const ( zhangsan = 1 lisi wangwu = 2 zhaoliu ) // 1,1,2,2 fmt.Println(zhangsan,lisi,wangwu,zhaoliu)&#125;//iota 从0开始,依次自增func enums2()&#123; const ( zhangsan = iota lisi wangwu zhaoliu ) //0,1,2,3 fmt.Println(zhangsan,lisi,wangwu,zhaoliu)&#125;// iota 存储位运算func enums3() &#123; const ( b = 1 &lt;&lt; (10 * iota) kb mb ) //1 1024 1048576 fmt.Println(b,kb,mb)&#125;func main() &#123; enums1() enums2() enums3()&#125; iota 从0开始，同一个const中iota不重置，会一直自增 在同一个函数中const每定义一次iota重置一次1234567891011121314151617181920package mainimport &quot;fmt&quot;func main()&#123; //iota一直会自增，相同cost中出现的iota，不会重置 //同一个函数中重新定义cost ，iota 会重置 const( a = iota b c d = 5 e = 5 f = iota g ) //0 1 2 5 5 5 6 //a=0,b=1,c=2,d自身应该等于3但是被覆盖,e=4被覆盖后为5,f=5,g=6 fmt.Println(a,b,c,d,e,f,g)&#125;]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux后台运行命令]]></title>
    <url>%2F2019%2F09%2F16%2FLinux%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运维实用命令]]></title>
    <url>%2F2019%2F08%2F14%2F%E8%BF%90%E7%BB%B4%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[随机密码生成：1echo &quot;`date &apos;+%D%N&apos;` $RANDOM $RANDOM `date &apos;+%D%N&apos;`&quot; | md5sum | head -c 16 &amp;&amp; echo &apos;&apos; 查询DDOS攻击IP列表：12linux: netstat -an|grep -i syn_recv|awk &apos;&#123;print $5&#125;&apos;|awk -F\: &apos;&#123;print $1&#125;&apos;|sort|uniq -cbsd: netstat -an|grep -i syn_recv|awk &apos;&#123;print $5&#125;&apos;|awk -F\. &apos;&#123;print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4&#125;&apos;|sort|uniq -c 取IP地址12ifconfig | grep &apos;inet addr:&apos;| grep -v &apos;127.0.0.1&apos; | cut -d: -f2 | awk &apos;&#123; print $1&#125;&apos;hostname -I 按cpu利用率从大到小排列1ps -e -o &quot;%C : %p : %z : %a&quot;|sort -nr vim 批量替换1%s/lvzheng/testlvzheng/g 列出cpu 占有率高于 8% 的进程的PID1ps aux | awk &apos;&#123; if ($3 &amp;gt; 8 ) print $2&#125;&apos; 监控java线程数：1ps -eLf | grep java | wc -l 监控网络客户连接数：12netstat -n | grep tcp | grep 侦听端口 | wc -l上面两个命令，可改动grep的参数，来达到更细致的监控要求。 在Linux系统一切都是文件的思想贯彻指导下，所有进程的运行状态都可以用文件来获取。系统根目录/proc中，每一个数字子目录的名字都是运行中的进程的PID，进入任一个进程目录，可通过其中文件或目录来观察进程的各项运行指标，例如task目录就是用来描述进程中线程的，因此也可以通过下面的方法获取某进程中运行中的线程数量（PID指的是进程ID）：1ls /proc/PID/task | wc -l 在linux中还有一个命令pmap，来输出进程内存的状况，可以用来分析线程堆栈：1pmap PID TCP状态1234567netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;netstat -n | awk &apos;/^tcp/ &#123;++state[$NF]&#125; END &#123;for(key in state) print key,&quot;\t&quot;,state[key]&#125;&apos;sysctl -a|grep net.ipv4.tcp_twsysctl -a | grep time | grep waitnet.ipv4.netfilter.ip_conntrack_tcp_timeout_time_wait = 120net.ipv4.netfilter.ip_conntrack_tcp_timeout_close_wait = 60net.ipv4.netfilter.ip_conntrack_tcp_timeout_fin_wait = 120 清除僵死进程1ps -eal | awk &apos;&#123; if ($2 == &quot;Z&quot;) &#123;print $4&#125;&#125;&apos; | kill -9 查杀mysql进程1ps aux|grep mysql|grep -v grep|awk &apos;&#123;print $2&#125;&apos;|xargs kill -9 查杀进程PID1kill -9 `cat /var/jboss.pid` 查杀8080端口相关的进程1lsof -i :8080|grep -v &quot;PID&quot;|awk &apos;&#123;print &quot;kill -9&quot;,$2&#125;&apos;|sh tcpdump 抓包1tcpdump -c 10000 -i eth0 -n dst port 80 &gt; /root/tcpdump.log 让linux的history命令显示时间记录1234567891011121314151617181920vim /etc/bashrc添加：#by:fycHISTFILESIZE=2000 #定义了在 .bash_history 中保存命令的记录总数HISTSIZE=2000 #定义了 history 命令输出的记录数#HISTIMEFORMAT=&quot;%Y%m%d-%H%M%S: &quot; #定义了执行命令的时间格式HISTTIMEFORMAT=&apos;%F %T &apos; ##这个方法显示更清晰。#!/bin/shID=`ps -ef | grep &quot;java&quot; | grep -v &quot;$0&quot; |grep jboss-4.2.2.GA_***| grep -v &quot;grep&quot; | awk &apos;&#123;print $2&#125;&apos;`for pid in $ID;do echo 时间：`date +%Y-%m-%d_%H:%M:%S` echo &quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot; echo &quot;[jboss-4.2.2.GA_***]&apos;s process: $pid&quot;; echo &quot;-------------------------------------------------------------------------------------------------------------------&quot; pstree -p $&#123;pid&#125; echo &quot;-------------------------------------------------------------------------------------------------------------------&quot; cat /proc/$&#123;pid&#125;/status echo &quot;-------------------------------------------------------------------------------------------------------------------&quot; 进程打开的文件句柄 lsof -n | grep $pid |wc -l echo &quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot; done]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表生成式，生成器，迭代器]]></title>
    <url>%2F2019%2F07%2F09%2F%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%EF%BC%8C%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354In [10]: a = [1,2,3,4,5]In [12]: [i+1 for i in a] Out[12]: [2, 3, 4, 5, 6]In [18]: a = (i+1 for i in a) In [19]: next(a) Out[19]: 2In [20]: next(a) Out[20]: 3In [21]: next(a) Out[21]: 4In [22]: next(a) Out[22]: 5In [23]: next(a) Out[23]: 6In [24]: next(a) ---------------------------------------------------------------------------StopIteration Traceback (most recent call last)&lt;ipython-input-24-15841f3f11d4&gt; in &lt;module&gt;----&gt; 1 next(a)斐波那契数In [32]: def fib(n): ...: count = 0 ...: a = 0 ...: b = 1 ...: while count &lt; n: ...: tmp = a ...: a = b ...: b = tmp + b ...: yield b ...: count += 1 In [35]: a = fib(20) In [36]: next(a) Out[36]: 1In [37]: next(a) Out[37]: 2In [38]: next(a) Out[38]: 3In [39]: next(a) Out[39]: 5In [40]: next(a) Out[40]: 8]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python操作Mysql数据库]]></title>
    <url>%2F2019%2F06%2F18%2Fpython%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[django-orm]]></title>
    <url>%2F2019%2F06%2F10%2Fdjango-orm%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django路由分组]]></title>
    <url>%2F2019%2F06%2F10%2Fdjango%E8%B7%AF%E7%94%B1%E5%88%86%E7%BB%84%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-HttpResponse，render，redirect的区别]]></title>
    <url>%2F2019%2F06%2F10%2Fdjango-HttpResponse%EF%BC%8Crender%EF%BC%8Credirect%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-fbv与cbv]]></title>
    <url>%2F2019%2F06%2F10%2Ffbv%E4%B8%8Ecbv%2F</url>
    <content type="text"></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django基本使用]]></title>
    <url>%2F2019%2F06%2F10%2Fdjango%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python深浅copy]]></title>
    <url>%2F2019%2F06%2F06%2Fpython%E6%B7%B1%E6%B5%85copy%2F</url>
    <content type="text"><![CDATA[当一份嵌套格式数据，想要完全独立使用，就要用到深copy，代码示例 123456789101112131415161718192021222324In [1]: mydic = &#123;&apos;name&apos;:&apos;gjw&apos;,&apos;age&apos;:&apos;18&apos;,&apos;tel&apos;:&#123;&apos;t1&apos;:177,&apos;t2&apos;:&apos;176&apos;&#125;&#125; In [2]: a = mydic In [3]: print(id(a),id(mydic)) 4363599304 4363599304In [4]: a = mydic.copy() In [5]: print(id(a),id(mydic)) 4365915912 4363599304In [6]: print(id(a[&apos;tel&apos;]),id(mydic[&apos;tel&apos;])) 4363599944 4363599944In [7]: import copy In [8]: a = copy.deepcopy(mydic) In [9]: print(id(a),id(mydic)) 4368508752 4363599304In [10]: print(id(a[&apos;tel&apos;]),id(mydic[&apos;tel&apos;])) 4366254944 4363599944 通过查询内存地址得出当直接赋值时，内存地址是完全一样的 当使用浅copy，内存地址发生了变化，而嵌套数据内存地址还是没发生变化 当使用deepcopy，内存地址完全发生了变化 内存地址如果是一样的话，那么修改数据两个变量都会发生变化 如果在嵌套格式的数据，想要完全独立，就需要deepcopy方法来实现]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html常用标签]]></title>
    <url>%2F2019%2F05%2F30%2Fhtml%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[常用标签，空格和特殊符号c因解析问题，加入了井字符 标签 作用 strong 加粗 单标签 em 倾斜 单标签 h1 -h6 标题 1-6级从大到小 单标签 p 段落标签 每一个p标签都是一段话 双标签 br 换行 单标签 hr 水平分割线 单标签 ur 无序列表，双标签，中包括li 标签双标签 装饰 ol 有序列表，双标签 ol 中li为 有序 1 2 3….. dl 定义列表，双标签 table 表格，双标签 可简单使用 border cellspacing css增加边框 tr 表格中行表示，双标签 th 表格中tr中行首加粗，双标签 td 表格中tr中行，双标签 caption 表格标题，双标签 a href 超链接，双标签 a target=”blank“ 配合href 点开后跳转新建标签页面 img src 添加图片 &#nbsp; 空格 &#copy; © 常用于网站尾部]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django安装及目录介绍]]></title>
    <url>%2F2019%2F05%2F30%2Fdjango%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[mac 安装django，python版本3.6，且加入了环境变量1234567pip3 install django #默认安装最新也可以pip install django == version 指定版本django-admin startproject mysite #创建一个django项目 名字为mysitepython3 -c &quot;import django; print(django.__path__)&quot; #获取安装路径cd /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/djangocd mysitepython3 manage.py runserver #启动创建的django 项目python3 manage.py startapp cmdb #创建一个应用 mysite 文件名 作用 settings.py 配置文件 urls.py 路由，URL对应关系 wsgi.py 遵循wsgi规范，uwsgi + nginx上线使用 mange.py 管理django cmdb 文件名 作用 migrations 记录数据库操作(表结构修改记录) admin 后台管理 app 对当前app进行配置 models orm，通过类创建数据库表 tests 单元测试 views 写当前app所有业务代码]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python面向对象]]></title>
    <url>%2F2019%2F05%2F30%2Fpython%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Python函数]]></title>
    <url>%2F2019%2F05%2F30%2FPython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[定义以def 关键字开头，后接函数名字和圆括号() 以冒号:结尾参数必须放在圆括号内，多个参数逗号分隔return 结束函数，默认返回Noneretrun 可以返回多个值，返回数据类型为元祖，可以用解包的方式多个变量接收多个返回参数 示例定义一个函数123456789101112131415161718192021222324252627282930313233343536373839In [1]: def hello(): ...: print(&apos;hello&apos;) ...: In [2]: hello() helloIn [3]: info = hello() helloIn [4]: print(info) NoneIn [5]: def hello(): ...: return &apos;nihao&apos; ...: In [6]: hello() Out[6]: &apos;nihao&apos;In [7]: info = hello() In [8]: print(info) nihaoIn [9]: def hello(): ...: return &apos;nihao&apos;,True ...: ...: In [10]: info = hello() In [11]: print(info) (&apos;nihao&apos;, True)In [12]: i,j = hello() In [13]: print(i,j) nihao True 关键字函数12345678In [1]: def count(x,y): ...: return x+y ...: In [2]: c = count(y=2,x=1) In [3]: c Out[3]: 3 默认值函数12345678In [4]: def count(x,y=10): ...: return x+y ...: In [5]: c = count(1) In [6]: c Out[6]: 11 可变位置函数，返回元祖1234567In [9]: def count(x,y,*z): ...: return x,y,z In [10]: c = count(1,2,3,4,5,6,7,8) In [11]: c Out[11]: (1, 2, (3, 4, 5, 6, 7, 8)) 可变关键字参数，返回字典1234567In [12]: def count(x,y,*z,**kw): ...: return x,y,z,kw In [13]: c = count(1,2,3,4,name=&apos;gjw&apos;) In [14]: c Out[14]: (1, 2, (3, 4), &#123;&apos;name&apos;: &apos;gjw&apos;&#125;)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python常用模块]]></title>
    <url>%2F2019%2F05%2F30%2Fpython%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[os模块os常用方法listdir 查看当前目录下所有的内容getcwd 查看当前工作环境路径isdir 是不是目录isfile 是不是文件abspath 获取绝对路径system 调用shellstat 获取文件属性chmod 修改权限kill 杀死进程12345678910111213141516171819In [1]: import os In [2]: os.listdir() Out[2]: [&apos;.ansible&apos;, &apos;.bash_history&apos;, &apos;.bash_profile&apos;,In [4]: os.getcwd() Out[4]: &apos;/Users/gjw&apos;In [6]: os.path.isdir(&apos;test&apos;) Out[6]: TrueIn [7]: os.path.isfile(&apos;test&apos;) Out[7]: FalseIn [8]: os.path.abspath(&apos;test&apos;) Out[8]: &apos;/Users/gjw/test&apos;In [10]: os.system(&apos;top&apos;) Out[10]: 0In [12]: os.stat(&apos;test&apos;) Out[12]: os.stat_result(st_mode=16877, st_ino=35820738, st_dev=16777220, st_nlink=2, st_uid=501, st_gid=20, st_size=68, st_atime=1556098265, st_mtime=1551781040, st_ctime=1551781040) sys 模块platform 查看系统argv 外部传入参数，列表形式getfilesystemencoding 获取文件读取到内存默认编码，文件系统编码getdefaultencoding 获取操作系统默认编码py3 默认utf8 而py2是ascii1234567In [13]: import sys In [14]: sys.platform Out[14]: &apos;darwin&apos;In [15]: sys.getfilesystemencoding() Out[15]: &apos;utf-8&apos;In [16]: sys.getdefaultencoding() Out[16]: &apos;utf-8&apos; time 模块time.localtime() 获取当前时间time.time() Unix时间time.sleep(3) 停止三秒，三秒后返回1234567In [1]: import time In [2]: time.time() Out[2]: 1560752868.344692In [3]: time.localtime() Out[3]: time.struct_time(tm_year=2019, tm_mon=6, tm_mday=17, tm_hour=14, tm_min=27, tm_sec=53, tm_wday=0, tm_yday=168, tm_isdst=0) datetime 模块datetime.datetime.now() 获取当前时间datetime.datetime.now() + datetime.timedelta(days = -1) 获取前一天时间 In [5]: import datetime In [6]: datetime.datetime.now() Out[6]: datetime.datetime(2019, 6, 17, 14, 28, 21, 397769) In [7]: datetime.datetime.now() + datetime.timedelta(days = -1) Out[7]: datetime.datetime(2019, 6, 16, 14, 29, 31, 698443)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python文件读写]]></title>
    <url>%2F2019%2F05%2F28%2Fpython%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[语法 12open(‘file’,&apos;r/w/a&apos;)打开一个文件，r代表读模式，w代表写模式，w会新建文件不管你有没有，a追加内容 w模式 123456789In [1]: fd = open(&apos;test.txt&apos;,&apos;w&apos;) In [2]: fd.write(&apos;1&apos;) Out[2]: 1In [3]: Do you really want to exit ([y]/n)? ygjwdeMacBook-Pro:~ gjw$ cat test.txt 1gjwdeMacBook-Pro:~ gjw$ r模式 1234In [1]: fd = open(&apos;test.txt&apos;,&apos;r&apos;) In [2]: fd.read() Out[2]: &apos;1&apos; a模式 123456789In [3]: fd = open(&apos;test.txt&apos;,&apos;a&apos;) In [4]: fd.write(&apos;a&apos;) Out[4]: 1In [5]: fd = open(&apos;test.txt&apos;,&apos;r&apos;) In [6]: fd.read() Out[6]: &apos;1a&apos;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python异常处理]]></title>
    <url>%2F2019%2F05%2F28%2Fpython%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[语法: 123456try: except TypeError: #相当于if判断 except 错误类型: #多个except elif except Exception as e: #如果所有的except都没捕获到，就走Exception else: #没有异常，走else语句 finally: #总会被执行，不管有没有异常 try 基本使用 12345678910111213141516171819In [4]: 1 + &quot;2&quot; ---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-4-db092cb74d2d&gt; in &lt;module&gt;----&gt; 1 1 + &quot;2&quot;TypeError: unsupported operand type(s) for +: &apos;int&apos; and &apos;str&apos;# 这时程序报错会退出如果用 try处理，只会抛出异常,下面的程序会接着执行In [5]: try: ...: 1 + &quot;2&quot; ...: except TypeError: ...: print(&apos;str to int error.&apos;) ...: except Exception as e: ...: print(e) ...: print(&apos;test&apos;) ...: ...: str to int error.test Exception使用,会将没有定义的异常，抛出 12345678In [6]: try: ...: 1 + abc ...: except TypeError: ...: print(&apos;str to int error.&apos;) ...: except Exception as e: ...: print(e) ...: name &apos;abc&apos; is not defined]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python列表常用方法]]></title>
    <url>%2F2019%2F05%2F21%2Fpython%E5%88%97%E8%A1%A8%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[查看列表有哪些方法 12&gt;&gt;&gt; dir(list)[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__delitem__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__iadd__&apos;, &apos;__imul__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;append&apos;, &apos;clear&apos;, &apos;copy&apos;, &apos;count&apos;, &apos;extend&apos;, &apos;index&apos;, &apos;insert&apos;, &apos;pop&apos;, &apos;remove&apos;, &apos;reverse&apos;, &apos;sort&apos;] append列表中追加内容 1234&gt;&gt;&gt; lst = [1,2,3,4]&gt;&gt;&gt; lst.append(5)&gt;&gt;&gt; lst[1, 2, 3, 4, 5] count统计列表中元素出现的次数 12345&gt;&gt;&gt; lst.append(1)&gt;&gt;&gt; lst.count(1)2&gt;&gt;&gt; lst.count(2)1 extend追加内容，但是不会出现列表嵌套结构，append会嵌套 12345678&gt;&gt;&gt; lst1 = [1,2,3]&gt;&gt;&gt; lst.append(lst1)&gt;&gt;&gt; lst[1, 2, 3, 4, 5, 1, [1, 2, 3]]&gt;&gt;&gt; lst.extend(lst1)&gt;&gt;&gt; lst[1, 2, 3, 4, 5, 1, [1, 2, 3], 1, 2, 3]&gt;&gt;&gt; index 返回索引位置 12&gt;&gt;&gt; lst.index(1)0 insert 插入内容，指定索引位置 1234&gt;&gt;&gt; lst.insert(0,&apos;a&apos;)&gt;&gt;&gt; lst[&apos;a&apos;, 1, 2, 3, 4, 5, 1, [1, 2, 3], 1, 2, 3]&gt;&gt;&gt; pop 删除列表内容，按照索引位置，返回删除信息 1234&gt;&gt;&gt; lst.pop(0)&apos;a&apos;&gt;&gt;&gt; lst[1, 2, 3, 4, 5, 1, [1, 2, 3], 1, 2, 3] remove 移除列表内容，不反回移除信息 1234&gt;&gt;&gt; lst.remove(1)&gt;&gt;&gt; lst[2, 3, 4, 5, 1, [1, 2, 3], 1, 2, 3]&gt;&gt;&gt; reverse 反转列表 1234&gt;&gt;&gt; lst = [1,2,3,4,5,6]&gt;&gt;&gt; lst.reverse()&gt;&gt;&gt; lst[6, 5, 4, 3, 2, 1] sort 排序 123&gt;&gt;&gt; lst.sort()&gt;&gt;&gt; lst[1, 2, 3, 4, 5, 6]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符常用方法]]></title>
    <url>%2F2019%2F05%2F21%2Fpython%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字符串方法 查看字符串有哪些方法 1234&gt;&gt;&gt; mystr&apos;1,2,3,2,a,b,c,a&apos;&gt;&gt;&gt; dir(mystr)[&apos;__add__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__getnewargs__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__mod__&apos;, &apos;__mul__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__rmod__&apos;, &apos;__rmul__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;capitalize&apos;, &apos;casefold&apos;, &apos;center&apos;, &apos;count&apos;, &apos;encode&apos;, &apos;endswith&apos;, &apos;expandtabs&apos;, &apos;find&apos;, &apos;format&apos;, &apos;format_map&apos;, &apos;index&apos;, &apos;isalnum&apos;, &apos;isalpha&apos;, &apos;isdecimal&apos;, &apos;isdigit&apos;, &apos;isidentifier&apos;, &apos;islower&apos;, &apos;isnumeric&apos;, &apos;isprintable&apos;, &apos;isspace&apos;, &apos;istitle&apos;, &apos;isupper&apos;, &apos;join&apos;, &apos;ljust&apos;, &apos;lower&apos;, &apos;lstrip&apos;, &apos;maketrans&apos;, &apos;partition&apos;, &apos;replace&apos;, &apos;rfind&apos;, &apos;rindex&apos;, &apos;rjust&apos;, &apos;rpartition&apos;, &apos;rsplit&apos;, &apos;rstrip&apos;, &apos;split&apos;, &apos;splitlines&apos;, &apos;startswith&apos;, &apos;strip&apos;, &apos;swapcase&apos;, &apos;title&apos;, &apos;translate&apos;, &apos;upper&apos;, &apos;zfill&apos;] count 统计字符串中出现的个数 1234&gt;&gt;&gt; mystr.count(&apos;1&apos;)1&gt;&gt;&gt; mystr.count(&apos;a&apos;)2 startswith 查看字符串是不是以什么开头,返回布尔值 1234&gt;&gt;&gt; mystr.startswith(&apos;a&apos;)False&gt;&gt;&gt; mystr.startswith(&apos;1&apos;)True endswith 查看字符串是不是以什么结尾，返回布尔值 1234&gt;&gt;&gt; mystr.endswith(&apos;a&apos;)True&gt;&gt;&gt; mystr.endswith(&apos;1&apos;)False find 检查字符串中是否有字符，指定开始与结尾，不存在返回-1 12345678&gt;&gt;&gt; mystr.find(&apos;a&apos;,0,2)-1&gt;&gt;&gt; mystr&apos;1,2,3,2,a,b,c,a&apos;&gt;&gt;&gt; mystr.find(&apos;a&apos;,1)8&gt;&gt;&gt; mystr.find(&apos;1&apos;,0,2)0 format 格式化输出 12&gt;&gt;&gt; &apos;hello my name is &#123;&#125;&apos;.format(&apos;gjw&apos;)&apos;hello my name is gjw&apos; index 查找字符串索引位置 1234&gt;&gt;&gt; mystr.index(&apos;1&apos;)0&gt;&gt;&gt; mystr.index(&apos;a&apos;)8 isdigit 是不是数字组成，返回布尔值 12345&gt;&gt;&gt; mystr.isdigit()False&gt;&gt;&gt; mystr1 = &apos;123&apos;&gt;&gt;&gt; mystr1.isdigit()True islower 是不是小写，返回布尔值 12345&gt;&gt;&gt; mystr.islower()True&gt;&gt;&gt; mystr1 = &apos;ABC&apos;&gt;&gt;&gt; mystr1.islower()False isupper 是不是大写，返回布尔值 1234&gt;&gt;&gt; mystr1.isupper()True&gt;&gt;&gt; mystr.isupper()False join 连接字符串 1234&gt;&gt;&gt; str = &apos;-&apos;&gt;&gt;&gt; seq = (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)&gt;&gt;&gt; str.join( seq )&apos;a-b-c&apos; ljust 字符串左对齐,默认使用空格填充至指定长度的新字符串 123&gt;&gt;&gt; str = &apos;hi&apos;&gt;&gt;&gt; str.ljust(10,&apos;!&apos;)&apos;hi!!!!!!!!&apos; lower 将字符串转换为小写 1234&gt;&gt;&gt; mystr = &apos;ABC&apos;&gt;&gt;&gt; &gt;&gt;&gt; mystr.lower()&apos;abc&apos; lstrip 去掉字符串左边空格，或指定字符 123&gt;&gt;&gt; mystr = &apos;abcdef&apos;&gt;&gt;&gt; mystr.lstrip(&apos;a&apos;)&apos;bcdef&apos; replace 替换字符串 123&gt;&gt;&gt; mystr.replace(&apos;f&apos;,&apos;a&apos;)&apos;abcdea&apos;&gt;&gt;&gt; rjust 字符串右对齐,默认使用空格填充至指定长度的新字符串 123&gt;&gt;&gt; mystr = &apos;hi&apos;&gt;&gt;&gt; mystr.rjust(10,&apos;!&apos;)&apos;!!!!!!!!hi&apos; split 字符串切分返回列表 12&gt;&gt;&gt; mystr.split(&apos;c&apos;)[&apos;ab&apos;, &apos;ab&apos;, &apos;&apos;] strip 去除指定字符 123&gt;&gt;&gt; mystr.strip(&apos;a&apos;)&apos;bcabc&apos;&gt;&gt;&gt; upper 将字符串变为大写 123&gt;&gt;&gt; mystr.upper()&apos;ABCABC&apos;&gt;&gt;&gt;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes简介]]></title>
    <url>%2F2019%2F05%2F17%2Fkubernetes-e7-ae-80-e4-bb-8b%2F</url>
    <content type="text"><![CDATA[Kubernetes是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动 化部署、自动扩缩容、维护等功能，因为k中间有8个字母，简称k8s。 使用k8s的好处 快速部署应用快速扩展应用无缝对接新的应用功能节省资源，优化硬件资源的使用 k8s不是什么 k8s并不是传统的PaaS(平台即服务)系统。k8s不限制支持应用的类型，不限制应用框架，但限制受支持的语言 runtimes。k8s不提供中间件、数据处理框架、数据库或者集群存储系统(如Ceph)作 为内置服务。k8s不部署源码不编译应用。k8s允许用户选择自己的日志、监控和报警系统。k8s不提供或授权一个全面的应用程序配置 语言/系统。k8s不提供任何机器配置、维护、管理或者自修复系统。 k8s集群对象 k8s集群一切皆对象，常见对象，标准资源pod k8s容器最小单元一个pod可以跑多个容器，多个容器组成一个podnamespace 命名空间，交付到不同名称空间的pod，通讯时要加上名称空间deployment pod的控制器，pod状态管理daemonset 每个node都要起一个service 统一接入口，发现pod，代理pod，负载均衡podingress 外部访问 k8s主要组件 master 控制节点etcd 存储，保存集群数据，自带高可用机制，但是要部署奇数，避免脑裂apiserver 协调调度scheduler pod资源调度器controller-manager 管理集群，按照既定的策略运行 node 运算节点 kubelet 与docerk通讯交互kube-proxy 维护c网络，集群网络 addons 插件 coredns 维护对应关系service与clusteripflannel 维护p网络，pod跨宿主机通讯treaeik ingress集群内部服务为集群外提供服务]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bash命令执行无返回事件]]></title>
    <url>%2F2019%2F05%2F06%2Fbash-e5-91-bd-e4-bb-a4-e6-89-a7-e8-a1-8c-e6-97-a0-e8-bf-94-e5-9b-9e-e4-ba-8b-e4-bb-b6%2F</url>
    <content type="text"><![CDATA[开发人员反映测试机器卡怀疑磁盘满了，登陆本地服务器后发现 ls df -h 执行卡死control + c也无法结束，初步怀疑是磁盘，文件系统，使用mount后发现192.168.8.61 nfs挂载， 近期有基础办公环境迁移事件，ping此地址后不通，与it/开发人员确认后，没有使用此目录，果断卸载，后发现正常使用]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html常用标签]]></title>
    <url>%2F2019%2F04%2F30%2Fhtml-e5-b8-b8-e7-94-a8-e6-a0-87-e7-ad-be%2F</url>
    <content type="text"><![CDATA[整理了一些html常用标签，记录总结： strong 加粗 单标签em 倾斜 单标签h1 -h6 标题 1-6级从大到小 单标签p 段落标签 每一个p标签都是一段话 双标签br 换行 单标签hr 水平分割线 单标签ur 无序列表，双标签，中包括li 标签双标签 装饰ol 有序列表，双标签 ol 中li为 有序 1 2 3…..dl 定义列表，双标签table 表格，双标签 可简单使用 border cellspacing css增加边框tr 表格中行表示，双标签th 表格中tr中行首加粗，双标签td 表格中tr中行，双标签caption 表格标题，双标签a href 超链接，双标签a target=”_blank_“ 配合href 点开后跳转新建标签页面img src 添加图片&nbsp; 空格&copy; © 常用于网站尾部]]></content>
      <categories>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MongoDB使用mongoexport批量导出数据]]></title>
    <url>%2F2019%2F04%2F26%2Fmongodb-e4-bd-bf-e7-94-a8mongoexport-e6-89-b9-e9-87-8f-e5-af-bc-e5-87-ba-e6-95-b0-e6-8d-ae%2F</url>
    <content type="text"><![CDATA[最近在在查询mongo数据时遇到了一个批量导出的需求，所以下面介绍下MongoDB mongoexport使用方法: 首先看一下常用参数: -h,–host ：代表远程连接的数据库地址，默认连接本地Mongo数据库；–port：代表远程连接的数据库的端口，默认连接的远程端口27017；-u,–username：代表连接远程数据库的账号，如果设置数据库的认证，需要指定用户账号；-p,–password：代表连接数据库的账号对应的密码；-d,–db：代表连接的数据库；-c,–collection：代表连接数据库中的集合；-f, –fields：代表集合中的字段，可以根据设置选择导出的字段；–type：代表导出输出的文件类型，包括csv和json文件；-o, –out：代表导出的文件名；-q, –query：代表查询条件；–skip：跳过指定数量的数据；–limit：读取指定数量的数据记录； 在导出前首先确定，查询语句是否是正确的: 查询为复杂查询，使用了and因为有时间条件限制 ，其中new data 是通过ISODate(“2019-04-24T00:00:00.00Z”).valueOf()得出，这个得出的时间为格林尼治时间，与北京时间相差8小时，也就是+8为当前系统时间 然后使用mongoexport命令查询，注意命令在安装目录下的bin下，如果没做软连接会提示没有命令，在脚本中也注意绝对路径的使用: #!/bin/bash zid=(15610)for i in ${zid[*]}; do mongoexport -d tank -c z$i -q ‘{$and:[{“request” : “areateamwar.takegems”},{ “time” : { “$gte” : new Date(1556064000000) , “$lt” : new Date(1556236800000) } }]}’ –out ztakegems$i.txtdone #其实就是将 -q 里填入查询条件 查看结果: 至此所需内容已批量循环导出，剩下的可以通过scp rsync 等方法放至本地]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python生成配置文件]]></title>
    <url>%2F2019%2F04%2F04%2Fpython-e9-85-8d-e7-bd-ae-e6-96-87-e4-bb-b6-e7-94-9f-e6-88-90%2F</url>
    <content type="text"><![CDATA[运维工作中，有很多时候需要改配置文件，或者写配置文件，这篇文章主要记录通过python str模版方法生成配置文件，适用不复杂情况，如果配置文件复杂就需要用jinjia2，小胡子等方法生成 str模版示例: tpl模版 &lt;host&gt;{host}&lt;/host&gt; &lt;user&gt;{user}&lt;/user&gt; python代码 tpl_file = ‘mysql.tpl’ conf_file = ‘mysql_conf’ tpl = open(tpl_file).read() open(conf_file,’wt’).write(tpl.format(host=’127.0.0.1’,user=’test’)) 结果 gjwdeMacBook-Pro:py gjw$ cat mysql_conf 127.0.0.1 test 如果要生成配置文件带有{} 需要将配置文件中{ {}}取消歧义，注意，不是传递的值{ {mysql}}取消]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普罗米修斯监控介绍]]></title>
    <url>%2F2019%2F03%2F25%2Fe6-99-ae-e7-bd-97-e7-b1-b3-e4-bf-ae-e6-96-af-e7-9b-91-e6-8e-a7-e4-bb-8b-e7-bb-8d%2F</url>
    <content type="text"><![CDATA[本文内容主要介绍普罗米休斯特性 简介 2012年诞生,监控与报警系统的集合, soundcloud 创建,2016年加入cncf 成为k8s 后加入该组织第二个成员开源,多组织联合维护开发 特性 基于时间序列模型,数据精准(时间序列: 一系列有序数据,等时时间间隔的采样数据),基于k,v数据模型,快速,易开发,维护,采用http,两种采集模式(pull push)开源,大量插件 框架架构 类cs架构运行模式,一个进程方式启动,之后多进程多线程实现监控数据收集、计算、查询、更新、存储 存储方式 采用时间序列方式存储,存储在本地磁盘,每两个小时间隔来分割block存储,每一个块中又分为多个chunk文件chunk文件是用来存放采集来的时间序列数据,index和 metadata是chunk的子集index文件是对metrics(采集一次k／v数据叫做metrics) 和labels标签进行索引存储在chunk中metadata又称中介数据、中继数据,用来支持如指示存储位置、历史数据、资源查找、文件记录等功能普罗米修斯会将采集中的数据先放入内存中,以类似缓存的方式加快搜索访问当出现宕机时,会有一种保护机制WAL,可以定期将数据存入硬盘中以chunk来表示,并在重启后进行恢复内存最后图中metadata画的过程中出现了输入错误，大家见谅 缺点 数据采集精度大,如果集群数量太大,监控有性能瓶颈,暂不支持集群(1.8版本以后开始支持增加remote read配置http拉取数据),对磁盘资源消耗也很大,学习成本大,数学命令行 插件 exporter Prometheus支持许多种exporter，如HAProxy，Jenkins，MySQL等 插件 pushgateway Prometheus 采用 pull 模式，可能由于不在一个子网或者防火墙原因，导致 Prometheus 无法直接拉取各个 target 数据，在监控业务数据的时候，需要将不同数据汇总, 由 Prometheus 统一收集。它就相当于一个缓存，当数据采集完成之后，就上传到这里，由Prometheus稍后再pull过来。 插件 alertmanager Alertmanager 主要用于接收 Prometheus 发送的告警信息，它支持丰富的告警通知渠道，而且很容易做到告警信息进行去重，降噪，分组等]]></content>
      <categories>
        <category>监控</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jenkins脚本启动jar包失败]]></title>
    <url>%2F2019%2F03%2F22%2Fjenkins-e5-90-af-e5-8a-a8jar-e5-8c-85-e5-a4-b1-e8-b4-a5%2F</url>
    <content type="text"><![CDATA[最近遇到一个问题，jenkins自由风格项目，脚本启动jar包启动失败，单独在服务器执行脚本没问题，也没有报错，原因为启动jar包需要进入对应目录，特此记录 最初执行方式如下: 执行无报错但是jar包未启动 更改后: 启动成功]]></content>
      <categories>
        <category>爬坑之路</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 统计ip地址归属地]]></title>
    <url>%2F2019%2F03%2F15%2Fpython-e7-bb-9f-e8-ae-a1ip-e5-9c-b0-e5-9d-80-e5-bd-92-e5-b1-9e-e5-9c-b0%2F</url>
    <content type="text"><![CDATA[接到一个运营需求，统计地区玩家分布数量，使用17MonIPpython库完成了这个统计代码如下: 需要pip安装库 import os from concurrent.futures import ThreadPoolExecutor from collections import Counter import IP ip_list = Counter() lst = [] addr_lst = [] t_list = [] with open(r’ip.txt’) as f: for line in f: lst.append(line.strip(‘\n’).strip(‘\t’)) def func(i): addr = IP.find(i) addr_lst.append(addr) t_pool = ThreadPoolExecutor(os.cpu_count() * 5) for i in lst: t_pool.submit(func, i) t_pool.shutdown() ip_list.update(addr_lst) print(ip_list) 最后数据处理完成（ip是从数据库中查询保存的）： 如果看着\t不爽的话，先把字符串切割成列表，再join成字符串。 相关库github 地址:https://github.com/17mon/python]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github私库release文件下载]]></title>
    <url>%2F2019%2F03%2F05%2Fgithub-e7-a7-81-e5-ba-93release-e6-96-87-e4-bb-b6-e4-b8-8b-e8-bd-bd%2F</url>
    <content type="text"><![CDATA[1.token获取 选择完成后点最下方创建，会给出一个token，只显示一次，需要保存好 2.文件下载 附送脚本: echo “GITHUB_API_TOKEN=youtoken” &gt;&gt;~/.secrets #!/bin/bashCWD=”$(cd -P – “$(dirname – “$0”)” &amp;&amp; pwd -P)” # Check dependencies.set -etype curl grep sed tr &gt;&amp;2xargs=$(which gxargs || which xargs) # Validate settings.[ -f ~/.secrets ] &amp;&amp; source ~/.secrets[ “$GITHUB_API_TOKEN” ] || { echo “Error: Please define GITHUB_API_TOKEN variable.” &gt;&2; exit 1; }[ $# -ne 4 ] &amp;&amp; { echo “Usage: $0 [owner] [repo] [tag] [name]“; exit 1; }[ “$TRACE” ] &amp;&amp; set -xread owner repo tag name &lt;&lt;&lt;$@ # Define variables.GH_API=”https://api.github.com&quot;GH_REPO=”$GH_API/repos/$owner/$repo”GH_TAGS=”$GH_REPO/releases/tags/$tag”AUTH=”Authorization: token $GITHUB_API_TOKEN”WGET_ARGS=”–content-disposition –auth-no-challenge –no-cookie”CURL_ARGS=”-LJO#” # Validate token.curl -o /dev/null -sH “$AUTH” $GH_REPO || { echo “Error: Invalid repo, token or network issue!”; exit 1; } # Read asset tags.response=$(curl -sH “$AUTH” $GH_TAGS)# Get ID of the asset based on given name.eval $(echo “$response” | grep -C3 “name.:.\+$name” | grep -w id | tr : = | tr -cd ‘[[:alnum:]]=’)[ “$id” ] || { echo “Error: Failed to get asset id, response: $response” | awk ‘length($0)&lt;100’ &gt;&2; exit 1; }GH_ASSET=”$GH_REPO/releases/assets/$id” # Download asset file.echo “Downloading asset…” &gt;&amp;2curl $CURL_ARGS -H ‘Accept: application/octet-stream’ “$GH_ASSET?access_token=$GITHUB_API_TOKEN”echo “$0 done.” &gt;&amp;2 #3使用方法sh get.sh username test v0.1 ***.py（用户 存储库 tag 文件名）]]></content>
      <categories>
        <category>Linux基础</category>
        <category>爬坑之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[监控设计概述]]></title>
    <url>%2F2019%2F03%2F04%2Fe7-9b-91-e6-8e-a7-e6-a6-82-e8-bf-b0%2F</url>
    <content type="text"><![CDATA[监控是什么？ 说⽩了 就是⽤⼀种形式 去盯着 观察服务器 把服 务器的各种⾏为表现都显示出来 ⽤以发现问题 和不⾜。报警是什么？ 监控和报警这两个词⼀定要分开说，分开理解！ 监控是监控 报警是报警。 监控是把⾏为表现展示出来，⽤来观察的，报警则是，当监控获取的数据，发⽣异常并且到达了某个临界点的时候，采⽤各种途径来通知运维⼈员。 1 监控架构设计 评估 业务流程，框架，体系 业务／系统／网络／代码／日志／用户行为／等监控 业务: qps dau 访问状态 用户接口 系统: cpu 内存 磁盘 等 网络: 延迟 丢包 进出口流量 代码: 开发配合 日志: elk （系统，业务) 2.监控系统搭建 服务端 客户端 采集程序单点测试 采集程序批量部署 服务端 ha 图形化搭建 报警系统测试 报警规则测试 监控 &amp; 报警联合测试 上线 3 稳定性测试 一段时间后: 单点服务部署后，对服务器，业务是否有影响 集群服务部署后，对服务器，业务是否有影响 4 自动化监控 批量部署 salt ansible]]></content>
      <categories>
        <category>监控</category>
      </categories>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql主从复制错误]]></title>
    <url>%2F2019%2F01%2F22%2Fmysql-e4-b8-bb-e4-bb-8e-e5-a4-8d-e5-88-b6-e9-94-99-e8-af-af%2F</url>
    <content type="text"><![CDATA[近期公司即将放假，巡检mysql主从，发现两个问题，总结记录: 错误:1236could not find first log file name in binary log index fileslave操作:stop slave;master 操作:flush logs; #生成新的binlog文件show master status; #查看日志文件和位置slave操作:change master to master_log_file=’mysql-bin.000325’ , master_log_pos=2326356;start slave; 错误:Relay log read failure: Could not parse relay log event entry. The possible reasons are: the master’s binary log is corrupted (you can check this by running ‘mysqlbinlog’ on the binary log), the slave’s relay log is corrupted (you can check this by running ‘mysqlbinlog’ on the relay log), a network problem, or a bug in the master’s or slave’s MySQL code. If you want to check the master’s binary log or slave’s relay log, you will be able to know their names by issuing ‘SHOW SLAVE STATUS’ on this slave. slave操作:show slave status\G; #拿出以下两个信息Master_Log_FileExec_Master_Log_Pos stop slave;change master to master_log_file=’mysql-bin.000325’ , master_log_pos=2326356;start slave;写在最后，如果主从错误问题解决不了，最快的方式，重做主从]]></content>
      <categories>
        <category>爬坑之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python分析Nginx日志]]></title>
    <url>%2F2019%2F01%2F21%2Fpython-e5-88-86-e6-9e-90nginx-e6-97-a5-e5-bf-97%2F</url>
    <content type="text"><![CDATA[python 实现nginx 日志 ip，url，状态码统计，并取TOP10 #encoding: utf-8 fd = open(‘access.log’, ‘rt’) #打开日志，读文本模式 stats = {} for i in fd: nodes = i.split() #空格切分 ，按照索引0就是ip，6是url，8是状态码 key = &apos;{ip}@{url}@{status\_code}&apos;.format(ip=nodes\[0\], url=nodes\[6\], status\_code=nodes\[8\])#字符串 if key notin stats: #如果存在+1 不存在=1 stats\[key\] = 1 else: stats\[key\] += 1 fd.close() lines = [] for key, value in stats.items(): lines.append((value, key)) #遍历，存储 print(lines[:2]) lines.sort() #sort 排序 tpl = ‘|{ip:&lt;25}|{url:&lt;70}|{status_code:&lt;8}|{count:&lt;8}|’ #自定义模版 header = tpl.format(ip=’ip’, url=’url’, status_code=’code’, count=’count’) print(‘-‘ * len(header)) print(header) print(‘-‘ * len(header)) for v, k in lines[-1:-11:-1]: #通过索引取前10 nodes = k.split(&apos;@&apos;) print(tpl.format(ip=nodes\[0\], url=nodes\[1\], status_code=nodes\[2\], count=value)) print(‘-‘ * len(header))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zabbix自定义监控排错过程]]></title>
    <url>%2F2018%2F12%2F21%2Fzabbix-e8-87-aa-e5-ae-9a-e4-b9-89-e7-9b-91-e6-8e-a7-e6-8b-8d-e9-94-99-e8-bf-87-e7-a8-8b%2F</url>
    <content type="text"><![CDATA[上午在帮一位同事查看自定义监控未生效时，发现一些问题，在此记录总结 1.开启自定义key选项zabbix_agentd.confUnsafeUserParameters=1 # 默认为0，表示不允许自定义keyUserParameter=你的脚本全路径加执行方式 2.脚本执行权限chmod +x xxx.sh 3.确认server端是否可以获取agent 数据 zabbix_get -s agent.ip -p 10050 -k 自定义key 4.延迟数据以上问题，在解决问题重启zabbix后，发现短期没数据，根据个人网路情况 5.解决问题的思路通过osi 七层模型，从物理层，依次往上排查，日志是最好的帮手。]]></content>
      <categories>
        <category>爬坑之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac vm fusion 安装]]></title>
    <url>%2F2018%2F12%2F19%2Fmac-vm-fusion-e5-ae-89-e8-a3-85%2F</url>
    <content type="text"><![CDATA[vm fusion 是Mac虚拟化产品之一，这篇文章主要介绍安装及ip分配静态化 下载安装官方地址： https://www.vmware.com/products/fusion.html vmware fusion 10 pro 序列号 FG3TU-DDX1M-084CY-MFYQX-QC0RD 按照固定版本号，下载后，直接下一步安装即可 虚拟机ip地址固定cd /Library/Preferences/VMware\ Fusion/ 确定虚拟机nat网卡 cat networking 确定网关 cd vmnet8/ cat nat.conf 已安装好的centos系统固定ip 更改dhcp为静态并配置 cd /etc/sysconfig/network-scripts vi ifcfg-ens33 BOOTPROTO=”static” IPADDR=172.16.181.10 NETMASK=255.255.255.0 GATEWAY=172.16.181.2 DNS1=172.16.181.2 DNS2=8.8.8.8 #重启网卡 systemctl restart network #或： /etc/init.d/network restart]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(四)]]></title>
    <url>%2F2018%2F12%2F17%2Fpython-e5-9f-ba-e7-a1-80-e5-9b-9b%2F</url>
    <content type="text"><![CDATA[在前几篇文章中，我们主要了解了python的一些基础内容，此篇文章，将主要介绍python逻辑判断与循环。 变量首先在这里要提到一个概念变量 ，什么是变量，能变得量，变量其实就是在用户空间内存中临时开创了一个空间。 举几个例子： > a = 10 &gt;&gt;&gt; print(a) 10 &gt;&gt;&gt; print(‘a’) a 此时我们发现，把10赋值给了a ，a就是一个变量，打印时不需要加引号，否则就是字符串 逻辑判断有哪些？and，or ，not。 从字面上来看，and就是和，or就是或者，not就是不是，那么在python中，他是如何理解这些逻辑判断的呢？ > print(‘True’ and ‘False’) False &gt;&gt;&gt; print(‘True’ or ‘False’) True 在以上执行结果中得出结论，and 两个值必须同时为真，结果为真，而or，一个为真，结果则为真。 逻辑判断–ifif判断，python中if判断是逻辑判断中最常用的语法，语法为: if 条件: pass (条件是真，执行此条) else: pass (else，否则执行这条) 下面，请看一个示例： num = int(input(‘请输入你的成绩: ‘)) if num &gt;= 90: print(&apos;优秀&apos;) elif num &gt;= 70: print(&apos;良&apos;) elif num &gt;= 60: print(&apos;及格&apos;) else: print(&apos;不及格&apos;) 此时发现程序会让输入一个数值，input 函数就是让我们交互输入，而elif 就是如果第一条判断为假，那么，就执行下面的，如果输入的都没有符合以上判断，最后都会打印，不及格！ 在上一小节中，介绍了python判断，这一节，将介绍python中循环是如何使用 while循环whille循环是可以无限循环的循环，只要不触发条件，此时我想输入一个数字让他不断相加，并求平均值，如果按exit 那么就退出: count = 0 count1 = 0 while True: num = input(&apos;请输入一个数字，exit退出：&apos;) if num ==&apos;exit&apos;: print(&apos;by&apos;) exit() else: count += int(num) count1 +=1 print(count) print(count /int(count1)) 再上面代码中，定义了两个变量，一个用来求和，一个计算输入的次数求平均值，通过第一个判断可以得到，用户是否还想继续输入，如果不想那么就使用exit 退出。 循环–for 在上面我们了解了whlie，while 循环，需要定义一个条件来刹车，否则就会一直执行下去，而for循环则是进行一个迭代的过程，比如，我想打印1-10 如何打印？ for i in range(1,11): print(i) range，在这里这个函数是生成数字1-10，for，in 迭代一个对象，对象值赋值给i 最后我们依次打印了这个i得出结果 那么while 循环如何打印呢？ i = 0 while i &lt;= 9: i += 1 print(i) 首先定义了一个变量i ，while 条件中 i 是小于等于9 也就是定义了一个刹车，每次循环让，i + 1 自增，最后循环一次打印一次。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(三)]]></title>
    <url>%2F2018%2F12%2F17%2Fpython-e5-9f-ba-e7-a1-80-e4-b8-89%2F</url>
    <content type="text"><![CDATA[在上一篇文章中，介绍了python数据类型，那么计算机中是否可以做四则运算呢？答案是可以的。本篇文章主要介绍python四则运算,与基础数据类型之间的转换。 python四则运算-字符串运算 > print(‘a’ * 3)aaa> print(‘a’ / 3)Traceback (most recent call last):File ““, line 1, in TypeError: unsupported operand type(s) for /: ‘str’ and ‘int’> print(‘a’ + 3)Traceback (most recent call last):File ““, line 1, in TypeError: must be str, not int> print(‘a’ - 3)Traceback (most recent call last):File ““, line 1, in TypeError: unsupported operand type(s) for -: ‘str’ and ‘int’ 此时我们发现字符串与数字，只可以相乘，得出结果，为乘数的倍数 那么字符串与字符串可以做四则运算吗？ > ‘a’ + ‘a’ ‘aa’ &gt;&gt;&gt; ‘a’ - ‘a’ Traceback (most recent call last): File ““, line 1, in TypeError: unsupported operand type(s) for -: ‘str’ and ‘str’ &gt;&gt;&gt; ‘a’ * ‘a’ Traceback (most recent call last): File ““, line 1, in TypeError: can’t multiply sequence by non-int of type ‘str’ &gt;&gt;&gt; ‘a’ / ‘a’ Traceback (most recent call last): File ““, line 1, in TypeError: unsupported operand type(s) for /: ‘str’ and ‘str’ &gt;&gt;&gt; 通过以上结果，我们可以得出，字符串与数字可以做乘法，而字符串与字符串，只能做加法，效果相当于两个字符串拼接 python四则运算–整数类型int > 1 + 12> 1 - 10> 1 * 11> 3 / 13.0 通过以上结果，我们可以得出，python中整数类型，是可以做加减乘除四则运算的，而做除法时，得出的结果是浮点数，也就是小数。 python数据类型转换在上篇文章中介绍到，’1’引号的是字符串类型，而字符串类型，是无法与数字进行除了乘法以运算，那么如何让输入的字符串类型，转换为int，又如何让int 转换为字符串呢？如果是布尔类型呢？ > int(‘1’) +23> int(‘5’) - 32> int(‘5’) * 315> int(‘5’) / 31.6666666666666667> type(int(‘5’)) > str(1) * 3‘111’> type(str(‘1’)) > str(True)‘True’> str(False)‘False’ 在以上代码中，我们可以得出，数据是可以互相进行转换的，而布尔值，转换后只是将原有的值，加了’引号’。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(二)]]></title>
    <url>%2F2018%2F12%2F17%2Fpython-e5-9f-ba-e7-a1-80-e4-ba-8c%2F</url>
    <content type="text"><![CDATA[在上一节介绍中，主要介绍了python发展历史，及第一行代码print(‘hello’)。那么如果输入一个print(1),他会显示什么呢，答案还是1，二者有什么区别吗？一个数字，一个是字母。这些在python中，就是基础的数据类型。 python基础数据类型常用的有如下几个： 整数(int) ,字符串(str),布尔值(bool),列表(list),元组(tuple),字典(dict),集合(set). python数据类型–字符串str当我们打印print函数时，传入的数据类型是什么呢？这时可以使用type()函数，查看对应数据类型。 [root@node1 ~]# pythonPython 3.6.4 (default, Dec 15 2018, 19:30:08)[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linuxType “help”, “copyright”, “credits” or “license” for more information. > print(‘hello’)hello> type(‘hello’) 程序给我们返回了str–在python中str就是字符串，一般以’单引号’ “双引号” 来定义 字符串常用操作: > my_str=’12345’ #定义字符串 &gt;&gt;&gt; len(my_str) #字符串长度 5 &gt;&gt;&gt; max(my_str) #最大值 ‘5’ &gt;&gt;&gt; min(my_str) #最小值 ‘1’ &gt;&gt;&gt; ‘1’ in my_str #判断字符串中是否存在 True &gt;&gt;&gt; 字符串函数: count 计算字符串中出现子字符串的次数 index 计算字符串中出现子字符串位置，若不存在则报错 find 计算字符串中出现子字符串位置，若不存在则返回-1 endswith/startswith 判断字符串是否以参数结尾/开头 format 格式化字符串 isalnum/isalpha/isdigit/isnumeric 判断字符串是否某类型的字符串 join 使用字符串连接序列 lower/upper 将字符串转成小写/大写 replace 替换字符串 split/splitlines 分隔字符串为list strip 去除字符串前后的空字符 > my_str.count(‘1’)1> my_str.index(‘1’)0> my_str.find(‘1’)0> my_str.find(‘9’)-1> my_str.endswith(‘5’)True> my_str.startswith(‘1’)True> my_str = ‘abcdef’> my_str.upper()‘ABCDEF’> my_str.lower()‘abcdef’> my_str.split()[‘abcdef’]> my_str = ‘ 1 a 2 b ‘> my_str.strip()‘1 a 2 b’ python数据类型–整数int > print(1) 1 &gt;&gt;&gt; type(1) &gt;&gt;&gt; print(‘1’) 1 &gt;&gt;&gt; type(‘1’) &gt;&gt;&gt; 在以上结果中我们又尝试了带引号的数字1与不带引号的，明显得出结果带引号数据类型为str，不带为int(也就是数字类型)。 python数据类型-浮点数float有了整数，那么就有小数，小数在python中，称为浮点数： > type(1.0) python数据类型–布尔bool布尔值就两种：True，False。就是反应条件的正确与否。 真 1 True。 假 0 False。 python数据类型–列表list定义一个列表： > my_list = [1,’a’,True,1.2] > my_list [1, ‘a’, True, 1.2] 从结果可以得出，列表可以是任意数据类型 查看列表中一个元素： > my_list [1, ‘a’, True, 1.2] > my_list[0] 1 > my_list[1] ‘a’ 列表是以索引来访问，从0开始 通过for循环遍历列表，依次打印列表每一个值： > for i in my_list: … print(i) … 1 a True 1.2 列表四则运算： > my_list + my_list1 [1, ‘a’, True, 1.2, 1, 2, 3] > my_list * 3 [1, ‘a’, True, 1.2, 1, ‘a’, True, 1.2, 1, ‘a’, True, 1.2] 得出结论：列表+列表，会把内容相加，列表*数字，会将列表内容重复 列表切片操作： > my_list=list(range(0,10))#定义从0-9列表 > my_list [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] > my_list[1:] #索引从1开始到最后 [1, 2, 3, 4, 5, 6, 7, 8, 9] > my_list[:5]#索引从开始到5 [0, 1, 2, 3, 4] > my_list[1:5:2] #索引1-5，步长是2，意思是间隔2 [1, 3] > my_list[::2] #索引从开始到最后，步长为2 [0, 2, 4, 6, 8] > my_list[-1] #索引-1 代表访问最后一个元素 9 常用切片操作： 反转： > my_list[:: -1] [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] 获取索引为偶数： > my_list[:: 2] [0, 2, 4, 6, 8] 获取索引为奇数： > my_list[1 :: 2] [1, 3, 5, 7, 9] 列表函数及常用操作： 查看函数 dir(),帮助函数help() append 添加元素到**list**最右侧 clear 清空**list**中的元素 copy 复制**list中的所有元素到新list**中并返回 count 计算**list**中存在相同元素的数量 extend 将一个可遍历数据中的所有元素追加到**list**后 index 获取元素在**list**中的位置 insert 在**list**指定位置添加元素 pop 弹出**list**中指定位置的元素（默认最右侧） remove 移除**list**中指定的元素 reverse**对list中元素进行反转 sort 对list中元素进行排序** > my_list.append(1) > my_list [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1] > my_list.clear() > my_list [] > my_list = my_list1.copy() > my_list [1, 2, 3] > my_list.count(1) 1 > my_list.extend(‘xyz’) > my_list [1, 2, 3, ‘x’, ‘y’, ‘z’] > my_list.index(1) 0 > my_list.insert(1,200) > my_list [1, 200, 2, 3, ‘x’, ‘y’, ‘z’] > my_list.pop() ‘z’ > my_list.pop(1) 200 > my_list [1, 2, 3, ‘x’, ‘y’] > my_list = [1,2,3] > my_list.reverse() > my_list [3, 2, 1] > my_list.sort() > my_list [1, 2, 3] 常见操作–长度，最小，最大值： > len(my_list) 3 > min(my_list) 1 > max(my_list) 3 > my_list [1, 2, 3] python数据类型–元祖tuple 元祖操作与列表基本相同，元祖可以切片，切片与列表规则相同，开始索引位置，结束索引位置，步长。但是元祖是不可变的，不可变指的是元组的内元素的值不可变，元祖以（）定时，但是一个元素时，元祖定义需要加，： > my_tuple = (1,) > my_tuple_1 = (1) > type(my_tuple) > type(my_tuple_1) 元祖也可以同时存在多种数据类型： > my_tuple_1 = (1,’abc’,True,[123]) > my_tuple_1 (1, ‘abc’, True, [123]) 元组名**[索引]**的方式访问元组中的元素： > my_tuple_1 (1, ‘abc’, True, [123]) > my_tuple_1[1] ‘abc’ 元祖与列表一样通过for 循环遍历: > for i in my_tuple_1: … print(i) … 1 abc True [123] 元祖四则运算与常用操作： > my_tuple_1 * 3 (1, ‘abc’, True, [123], 1, ‘abc’, True, [123], 1, ‘abc’, True, [123]) > my_tuple_1 + my_tuple (1, ‘abc’, True, [123], 1) #分别获区长度，最小，最大值 > my_tuple = (1,2,3) > len(my_tuple) 3 > min(my_tuple) 1 > max(my_tuple) 3 内置函数count／index： > my_tuple = (1,1,1,2,2,3,4,5) > my_tuple.count(1) 3 > my_tuple.index(1) 0 count 计算元祖内存在数量，index 获取索引位置 字典–dict以{}定义，kv对应，元素之间逗号分隔 字典常用操作: > me = {‘name’:’gjw’,’age’:18} > me {‘name’: ‘gjw’, ‘age’: 18} > type(me) > me[‘name’] ‘gjw’ > me[‘name’] = ‘abc’ > me {‘name’: ‘abc’, ‘age’: 18} > del me[‘name’] > me {‘age’: 18} 字典函数: clear 清空dict中的元素 copy 复制dict中的所有元素到新dict中并返回 fromkeys 根据序列生成dict，序列中所有元素作为key，value为fromkeys的第二个参数，默认为None get 返回dict中key对应的值，若key不存在则返回默认值 items 将dict转化为由每个元素均为两个子元素的序列组成的dict_items，可通过list将dict_items转化为list keys 返回dict中所有的key组成的dict_keys pop 通过key弹出字典中的元素，未设置默认值，当key不存在则报错，否则返回默认值 popitem 返回dict中的某个元素组成的元组(key, value) setdefault 设置dict中key的默认值（key不存在则设置）并返回dict中key的当前值 > me.clear() > me {} > me = {‘name’:’gjw’,’age’:18} > me_new = me.copy() > me_new {‘name’: ‘gjw’, ‘age’: 18} > id(me) 4423380352 > id(me_new) 4423381856 > me.get(‘name’) ‘gjw’ > me.items() dict_items([(‘name’, ‘gjw’), (‘age’, 18)]) > me.keys() dict_keys([‘name’, ‘age’])]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(一)]]></title>
    <url>%2F2018%2F12%2F17%2Fpython-e5-9f-ba-e7-a1-80-e4-b8-80%2F</url>
    <content type="text"><![CDATA[python简介什么是pythonPython 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序。Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。 一张图带你了解python 什么是程序？是为实现特定目标或解决特定问题而用计算机语言编写的命令序列的集合。简单来说，电脑里面的应用都是程序来控制的，程序天天见。 第一个程序员： 第一个python程序在之前的文章提到过使用centos安装python3.6版本，那么今天先运行第一个python程序hello。 在Linux终端，输入python，并输入print()函数执行第一个程序。 [root@node1 ~]# pythonPython 3.6.4 (default, Dec 15 2018, 19:30:08)[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linuxType “help”, “copyright”, “credits” or “license” for more information. > print(‘hello’)hello 这时程序返回了一个结果hello。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7.4升级python3.6]]></title>
    <url>%2F2018%2F12%2F15%2Fcentos7-4-e5-8d-87-e7-ba-a7python3-6%2F</url>
    <content type="text"><![CDATA[升级需谨慎！最好编译安装多版本！ 环境为： [root@node1 Python-3.6.4]# cat /etc/redhat-releaseCentOS Linux release 7.4.1708 (Core) 依赖及安装包下载yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel yum install -y wget sqlite-devel xz gcc automake zlib-devel openssl-devel epel-release wget https://www.python.org/ftp/python/3.6.4/Python-3.6.4.tgz 编译将python换为3.6tar -xvf Python-3.6.4.tgz cd Python-3.6.4 make &amp;&amp; make install mv /usr/bin/python /usr/bin/python.bak ln -s /usr/local/bin/python3 /usr/bin/python #此时进入python已经变为3.6 [root@node1 Python-3.6.4]# pythonPython 3.6.4 (default, Dec 15 2018, 19:30:08)[GCC 4.8.5 20150623 (Red Hat 4.8.5-36)] on linuxType “help”, “copyright”, “credits” or “license” for more information. > exit() 解决yum 下载出错[root@node1 Python-3.6.4]# yum install -y vimFile “/usr/bin/yum”, line 30except KeyboardInterrupt, e:^SyntaxError: invalid syntax #将如下俩个文件第一行变量python，变为python2.7 vi /usr/libexec/urlgrabber-ext-down vi /usr/bin/yum ipython下载[root@node1 ~]#/usr/local/bin/pip3.6 install ipython [root@node1 ~]#/usr/local/bin/pip3.6 install “ipython[notebook]“ [root@node1 ~]# whereis ipythonipython: /usr/bin/ipython /usr/local/bin/ipython /usr/share/man/man1/ipython.1.gz[root@node1 ~]# /usr/local/bin/ipythonPython 3.6.4 (default, Dec 15 2018, 19:30:08)Type ‘copyright’, ‘credits’ or ‘license’ for more informationIPython 7.2.0 – An enhanced Interactive Python. Type ‘?’ for help. In [1]: exit [root@node1 ~]# mv /usr/bin/ipython /usr/bin/ipython.bak[root@node1 ~]# ln -s /usr/local/bin/ipython /usr/bin/ipython]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础命令]]></title>
    <url>%2F2018%2F12%2F13%2Flinux-e5-9f-ba-e7-a1-80-e5-91-bd-e4-bb-a4%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redmine爬坑记]]></title>
    <url>%2F2018%2F12%2F13%2Fredmine-e7-88-ac-e5-9d-91-e8-ae-b0%2F</url>
    <content type="text"><![CDATA[故事发生在某天下午，一位运维同事安装redmine，但是迟迟未安装成功……….. 环境为centos 6.x 问题1 rails安装[root@svn openssl]# gem install rails -v=3.2.22 ERROR: While executing gem … (Gem::Exception) Unable to require openssl, install OpenSSL and rebuild Ruby (preferred) or use non-HTTPS sources 解决方法，更换ruby版本 gpg –keyserver hkp://keys.gnupg.net –recv-keys D39DC0E3 curl -L https://get.rvm.io | bash -s stable source /etc/profile.d/rvm.sh rvm reload rvm install 2.3.3 gem install rake -v 12.0.0 gem install rails -v 4.2.6 问题2 镜像源Could not verify the SSL certificate for https://ruby.taobao.org/. There is a chance you are experiencing a man-in-the-middle attack, but most likely your system doesn’t have the CA certificates needed for verification. For information about OpenSSL certificates, see http://bit.ly/ruby-ssl. To connect without using SSL, edit your Gemfile sources and change ‘https’ to ‘http’. 此问题更换http，https 尝试都无效，最后更换为源站 问题3 安装了 rmagick 提示出错An error occurred while installing rmagick 此问题为缺少依赖，需要安装依赖 yum install ImageMagick-devel yum install freetype-devel ghostscript-devel jasper-devel lcms-devel libpng-devel libtiff-devel zlib-devel libxml2-devel]]></content>
      <categories>
        <category>爬坑之路</category>
      </categories>
  </entry>
</search>
